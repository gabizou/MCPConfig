buildscript {
    repositories {
        mavenLocal()
        mavenCentral()
        jcenter()
        maven { url = 'http://files.minecraftforge.net/maven/'}
        maven { url = 'https://plugins.gradle.org/m2/' }
    }
    dependencies {
        classpath 'org.ow2.asm:asm:6.1.1'
        classpath 'org.ow2.asm:asm-tree:6.1.1'
        classpath 'net.md-5:SpecialSource:1.8.3'
        classpath 'net.minecraftforge:mapping-verifier:1.0.5+'
        classpath 'net.minecraftforge:mergetool:1.0.+'
        classpath 'de.undercouch:gradle-download-task:3.4.3'
    }
}

import de.oceanlabs.mcpconfig.task.MCInjectorTask
import de.oceanlabs.mcpconfig.task.RemapJarTask
import de.undercouch.gradle.tasks.download.Download
import groovy.io.FileType
import groovy.json.JsonSlurper
import groovy.json.JsonBuilder
import java.util.regex.Matcher
import org.objectweb.asm.Type
import net.minecraftforge.lex.ExtractInheritance
import net.minecraftforge.mappingverifier.MappingVerifier
import net.minecraftforge.mcpconfig.tasks.*
import uk.jamierocks.propatcher.task.ApplyPatchesTask
import uk.jamierocks.propatcher.task.MakePatchesTask
import net.minecraftforge.mergetool.Merger
import net.minecraftforge.mergetool.AnnotationVersion

plugins {
    id 'de.undercouch.download' version '3.3.0'
    id 'uk.jamierocks.propatcher' version '1.2.3' apply false
}
    
ext {
    archivesBaseName = 'mcp_config'
    group = 'de.oceanlabs.mcp'
    META_CACHE_FILE = 'meta_cache.json'
    META_CACHE = !file(META_CACHE_FILE).exists() ? [:] : new JsonSlurper().parseText(file(META_CACHE_FILE).text)
    VERSIONS = subprojects.collect{it.name}.sort{a,b -> compareVersion(a, b)} as List
}

task downloadVersionManifest(type: Download) {
    src 'https://launchermeta.mojang.com/mc/game/version_manifest.json'
    dest file('build/versions/version_manifest.json')
    overwrite true
    doLast {
        def json = new JsonSlurper().parseText(downloadVersionManifest.dest.text)
        
        //Update the cache of all versions we can.
        rootProject.subprojects.each { sub ->
            def entry = json.versions.find{it.id == sub.name}
            if (entry != null) 
                META_CACHE.get(sub.name, [:])['json'] = entry.url
        }
        META_CACHE = META_CACHE.sort{a,b -> compareVersion(a.key, b.key)} //I like it pretty so lets sort it.
        file(META_CACHE_FILE).write(new JsonBuilder(META_CACHE).toPrettyString())
        
        downloadVersionManifest.dest.write(new JsonBuilder(json).toPrettyString()) //Pretty it up
    }
}

def weeklyEdges = [
  '1.13': [17, 43, 18, 22]
]

def compareVersion(a, b) {
    def aIsWeek = a.length() == 6 && a.charAt(2) == 'w'
    def bIsWeek = b.length() == 6 && b.charAt(2) == 'w'
    if (aIsWeek == bIsWeek) {
        if (aIsWeek) {
            def (aYear, aWeek, aRev) = splitWeekly(a)
            def (bYear, bWeek, bRev) = splitWeekly(b)
            return aYear != bYear ? aYear - bYear : aWeek != bWeek ? aWeek - bWeek : aRev.compareTo(bRev)
        }
        return compareFull(a, b)        
    } else if (aIsWeek) {
        def (aYear, aWeek, aRev) = splitWeekly(a)
        def bFull = splitFull(b)[0].join('.')
        return compareFull(findFull(aYear, aWeek) + '-pre0', bFull)
    } else {
        def aFull = splitFull(a)[0].join('.')
        def (bYear, bWeek, bRev) = splitWeekly(b)
        return compareFull(aFull, findFull(bYear, bWeek) + '-pre0')
    }
}
def compareFull(a, b) {
    def (aFull, aPre) = splitFull(a)
    def (bFull, bPre) = splitFull(b)
    for (int x = 0; x < aFull.length; x++) {
        if (x >= bFull.length)
            return 1 //1.2.1 vs 1.2
        if (aFull[x] != bFull[x])
            return aFull[x] - bFull[x]
    }
    if (aFull.length < bFull.length)
        return -1 //1.2 vs 1.2.1
    return aPre - bPre  
}
def findFull(year, week) {
    def value = (year * 100) + week
    if (value >= 1743 && value <= 1822)
        return '1.13'
    throw new RuntimeException('Unknown week range: ' + value)
}
def splitWeekly(ver) {
    return [ver.substring(0, 2) as int, ver.substring(3, 5) as int, ver.substring(5)]
}
def splitFull(ver) {
    def pre = Integer.MAX_VALUE
    if (ver.indexOf('-') != -1) {
        pre = ver.split('-')[1].substring(3) as int
        ver = ver.split('-')[0]
    }
    return [ver.split('\\.').collect{it as int} as int[], pre]
}

subprojects {
    apply plugin: 'de.undercouch.download'
    apply plugin: 'maven'
    archivesBaseName = rootProject.archivesBaseName
    group = rootProject.group
    version = name

    ext {
        NULL_OUTPUT = new OutputStream() {
            public void write(int b){}
        }
        FORGE_MAVEN = 'http://files.minecraftforge.net/maven/'
        PATH_BUILD = rootProject.file('build').absolutePath
        PATH_VERSION = rootProject.file('versions').absolutePath + '/' + project.version + '/'
        PATH_DISTRO = PATH_BUILD + '/distributions'
        PATH_CACHED_LIBRARIES = PATH_BUILD + '/libraries/'
        PATH_CACHED_VERSIONS = PATH_BUILD + '/versions/'
        PATH_CACHED_VERSION = PATH_CACHED_VERSIONS + project.version + '/'
        PATH_CACHED_VERSION_DATA = PATH_CACHED_VERSION + 'data/'
        PATH_EXCEPTIONS =  file('exceptions.txt').exists() ? 'exceptions.txt' : rootProject.file('config/exceptions.txt').absolutePath
        PATH_ASTYLE = file('astyle.cfg').exists() ? 'astyle.cfg' : rootProject.file('config/astyle.cfg').absolutePath
        PATH_INJECT = file('inject').exists() ? file('inject') : null
        PATH_INJECT_TEMPLATE = PATH_INJECT == null || !new File(PATH_INJECT, 'package-info-template.java').exists() ? null : new File(PATH_INJECT, 'package-info-template.java')
        PROJECT_TEMPLATE = file('project_template.gradle').exists() ? file('project_template.gradle') : rootProject.file('project_template.gradle')
        
        CONFIG = file('config.json').exists() ? new JsonSlurper().parse(file('config.json')) : [:]
        MCINJECTOR = [
            version: CONFIG.get('mcinjector', [:]).version,
            args: CONFIG.mcinjector.get('args', []),
            path: mavenPath('de.oceanlabs.mcp:mcinjector:' + CONFIG.mcinjector.version + ':fatjar')
        ]
        FERNFLOWER = [
            version: CONFIG.get('fernflower', [:]).version,
            args: CONFIG.fernflower.get('args', []),
            jvmargs: CONFIG.fernflower.get('jvmargs', []),
            path: mavenPath('net.minecraftforge:forgeflower:' + CONFIG.fernflower.version)
        ]
        
        SRG = loadSRG(file(PATH_VERSION + 'joined.tsrg'))
    }
    
    tasks.whenTaskAdded {task ->
        def name = task.name.toLowerCase()
        if (MCINJECTOR.version == null && name.contains('mcinject')) {
            task.enabled = false
        }
        if ((MCINJECTOR.version == null || FERNFLOWER.version == null) && (name.contains('fernflower') || name.contains('project'))) {
            task.enabled = false
        }
    }

    task downloadJson(type: Download, dependsOn: rootProject.downloadVersionManifest) {
        inputs.file rootProject.downloadVersionManifest.dest
        doFirst {
            def json = new JsonSlurper().parseText(inputs.files.singleFile.text)
            def entry = json.versions.find{it.id == project.version}
            def url = entry != null ? entry.url : rootProject.META_CACHE.get(project.version, ['json':null]).json
            if (url == null)
                url = 'https://s3.amazonaws.com/Minecraft.Download/versions/' + project.version + '/' + project.version + '.json'
            downloadJson.src url
        }
        dest file(PATH_CACHED_VERSION + project.version + '.json')
        overwrite false
        doLast {
            def json = new JsonSlurper().parseText(downloadJson.dest.text)
            downloadJson.dest.write(new JsonBuilder(json).toPrettyString()) //Pretty it up
        }
    }
    task downloadClient(type: Download, dependsOn: downloadJson) {
        inputs.file downloadJson.dest
        doFirst {
            def json = new JsonSlurper().parseText(inputs.files.singleFile.text)
            downloadClient.src json.downloads.client.url
        }
        dest file(PATH_CACHED_VERSION + project.version + '.client.jar')
        overwrite false
    }
    task downloadServer(type: Download, dependsOn: downloadJson) {
        inputs.file downloadJson.dest
        doFirst {
            def json = new JsonSlurper().parseText(inputs.files.singleFile.text)
            downloadServer.src json.downloads.server.url
        }
        dest file(PATH_CACHED_VERSION + project.version + '.server.jar')
        overwrite false
    }
    task downloadLibraries(dependsOn: downloadJson) {
        inputs.file downloadJson.dest
        doLast {
            def json = new JsonSlurper().parseText(downloadJson.dest.text)
            json.libraries.each {lib ->
                def target = file(PATH_CACHED_LIBRARIES + lib.downloads.artifact.path)
                if (!target.exists()) {
                    download {
                        src lib.downloads.artifact.url
                        dest target
                    }
                }
            }
        }
    }
    task downloadMCInjector(type: Download) {
        src FORGE_MAVEN + MCINJECTOR.path
        dest file(PATH_CACHED_LIBRARIES + MCINJECTOR.path)
        overwrite false
    }
    task downloadFernflower(type: Download) {
        src FORGE_MAVEN + FERNFLOWER.path
        dest file(PATH_CACHED_LIBRARIES + FERNFLOWER.path)
        overwrite false
    }
    
    task filterClient(type: Zip, dependsOn: [downloadClient]) {
        archiveName = project.version + '.client.slim.jar'
        destinationDir = file(PATH_CACHED_VERSION)
        from zipTree(downloadClient.dest)
        SRG['CL:'].keySet().each{ include it + '.class' }
    }
    task filterClientExtra(type: Zip, dependsOn: [downloadClient]) {
        archiveName = project.version + '.client.extra.jar'
        destinationDir = file(PATH_CACHED_VERSION)
        from zipTree(downloadClient.dest)
        SRG['CL:'].keySet().each{ exclude it + '.class' }
    }
    task filterServer(type: Zip, dependsOn: [downloadServer]) {
        archiveName = project.version + '.server.slim.jar'
        destinationDir = file(PATH_CACHED_VERSION)
        from zipTree(downloadServer.dest)
        SRG['CL:'].keySet().each{ include it + '.class' }
    }
    task filterServerExtra(type: Zip, dependsOn: [downloadServer]) {
        archiveName = project.version + '.server.extra.jar'
        destinationDir = file(PATH_CACHED_VERSION)
        from zipTree(downloadServer.dest)
        SRG['CL:'].keySet().each{ exclude it + '.class' }
    }
    task filterJars(dependsOn: [filterClient, filterClientExtra, filterServer, filterServerExtra]){}
    
    task mergeJars(type: MergeJar, dependsOn: [filterClient, filterServer]) {
        client filterClient.archivePath
        server filterServer.archivePath
        annotate true
        version project.version
        mappings file(PATH_VERSION + 'joined.tsrg')
        dest file(PATH_CACHED_VERSION + project.version + '.joined.jar')
    }

    task renameClient(type: RemapJarTask, dependsOn: [downloadLibraries, filterClient]) {
        input filterClient.archivePath
        mappings file(PATH_VERSION + 'joined.tsrg')
        dest file(PATH_CACHED_VERSION + project.version + '.client.mapped.jar')
    }
    task renameServer(type: RemapJarTask, dependsOn: [downloadLibraries, filterServer]) {
        input filterServer.archivePath
        mappings file(PATH_VERSION + 'joined.tsrg')
        dest file(PATH_CACHED_VERSION + project.version + '.server.mapped.jar')
    }
    task renameJoined(type: RemapJarTask, dependsOn: [downloadLibraries, mergeJars]) {
        input mergeJars.dest
        mappings file(PATH_VERSION + 'joined.tsrg')
        dest file(PATH_CACHED_VERSION + project.version + '.joined.mapped.jar')
    }
    task renameJars(dependsOn: [renameClient, renameServer, renameJoined]){}
    
    task extractInheritance(type: ExtractInheritance, dependsOn: [downloadLibraries, mergeJars]) {
        input mergeJars.dest
        inputs.file downloadJson.dest
        dest file(PATH_CACHED_VERSION_DATA + 'inheritance.json')
        doFirst {
            def json = new JsonSlurper().parseText(downloadJson.dest.text)
            json.libraries.each{ addLibrary(file(PATH_CACHED_LIBRARIES + it.downloads.artifact.path)) }
        }
    }

    task makeSRG(type: SingleOutput) {
        inputs.file(PATH_VERSION + 'joined.tsrg')
        dest file(PATH_CACHED_VERSION_DATA + 'joined.srg')
        doLast {
            def SRG = loadSRG(inputs.files.singleFile)

            String.metaClass.rsplit = { chr -> [delegate.substring(0, delegate.lastIndexOf(chr)), delegate.substring(delegate.lastIndexOf(chr))] }
            dest.withWriter('UTF-8') { writer ->
                def format_class = { it.indexOf('/') != -1 ? it : it.split('\\$').collect{it.padLeft(1000, ' ')}.join('$') }
                def format_field = { format_class.call(it.rsplit('/')[0]) + '/' + it.rsplit('/')[1].padLeft(1000, ' ') }
                def format_method = { format_field.call(it.split(' ')[0]) + ' ' + it.split(' ')[1] }

                SRG['CL:'].sort{format_class.call(it.key)}.each{k,v -> writer.write('CL: ' + k + ' ' + v + '\n')}
                SRG['FD:'].sort{format_field.call(it.key)}.each{k,v -> writer.write('FD: ' + k + ' ' + v + '\n')}
                SRG['MD:'].sort{format_method.call(it.key)}.each{k,v -> writer.write('MD: ' + k + ' ' + v + '\n')}
            }
        }
    }
    task makeCSRG(type: SingleOutput) {
        inputs.file(PATH_VERSION + 'joined.tsrg')
        dest file(PATH_CACHED_VERSION_DATA + 'joined.csrg')
        doLast {
            def current = null
            dest.withWriter('UTF-8') { writer ->
                inputs.files.singleFile.collect{splitComment(it)[0]}.findAll{it != null}.each { line ->
                    if (!line.startsWith('\t')) {
                        current = line.split(' ')[0]
                        writer.write(line + '\n')
                    } else {
                        if (current == null)
                            throw new Exception("TSRG format screwed up... Null class context!")
                        writer.write(current + ' ' + line.trim() + '\n')
                    }
                }
            }
        }
    }

    task fixAccessLevels(type: SingleOutput, dependsOn: ['extractInheritance', 'makeSRG']) {
        inputs.file extractInheritance.dest
        dest file(PATH_CACHED_VERSION_DATA + 'access.txt')
        doLast {
            def srg = loadSRG(makeSRG.dest)
            def json = new JsonSlurper().parseText(inputs.files.singleFile.text)
            outputs.files.singleFile.withWriter('UTF-8') { writer ->
                json.each{ k,v ->
                    json[k]['methods']?.each{ sig,data ->
                        if (data['override']) {
                            def access = json[data['override']] ? json[data['override']]['methods'] ? json[data['override']]['methods'][sig] ? json[data['override']]['methods'][sig]['access'] : null : null : null
                            if (access != null) {
                                if ((data['access'] & 0b1010) == 0) { // STATIC PRIVATE
                                    def old = data['access'] & 0b0010 ? 0 : data['access'] & 0b0100 ? 2 : data['access'] & 0b0001 ? 3 : 1
                                    def top =       access   & 0b0010 ? 0 :       access   & 0b0100 ? 2 :       access   & 0b0001 ? 3 : 1
                                    def names = ['PRIVATE', 'DEFAULT', 'PROTECTED', 'PUBLIC']
                                    if (old < top) {
                                        def mapped = srg['MD:'][k + '/' + sig]
                                        if (mapped == null) {
                                            print('Missing srg mapping for access: ' + k + '/' + sig + '\n')
                                        }
                                        else {
                                            def mtd = mapped.split(' ')
                                            def ind = mtd[0].lastIndexOf('/')
                                            mtd = mtd[0].substring(0, ind) + ' ' + mtd[0].substring(ind+1) + ' ' + mtd[1]
                                            //println(mtd + " " + names[old] + " " + names[top])
                                            writer.write(names[top] + ' ' + mtd + '\n')
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    task dumpOverrides(type: SingleOutput, dependsOn: ['extractInheritance', 'makeSRG']) {
        inputs.file extractInheritance.dest
        dest file(PATH_CACHED_VERSION_DATA + 'overrides.txt')
        doLast {
            def srg = loadSRG(makeSRG.dest)
            def json = new JsonSlurper().parseText(inputs.files.singleFile.text)
            def methods = [] as HashSet

            json.each{ k,v ->
                json[k]['methods']?.each{ sig,data ->
                    if (data['override']) {
                        def mtd = srg['MD:'][k + '/' + sig]
                        methods.add(mtd)
                    }
                }
            }

            dest.withWriter('UTF-8') { writer ->
                methods = methods.sort{it}
                methods.each{ writer.write(it + '\n') }
            }
        }
    }

    task dumpStatic(type: SingleOutput, dependsOn: ['extractInheritance', 'makeSRG']) {
        inputs.file extractInheritance.dest
        dest file(PATH_CACHED_VERSION_DATA + 'static_methods.txt')
        doLast {
            def srg = loadSRG(makeSRG.dest)
            def json = new JsonSlurper().parseText(inputs.files.singleFile.text)
            def methods = [] as HashSet

            json.each{ cls,data ->
                data['methods']?.findAll{k,v -> (v['access'] & 0b1000) != 0}.each{ sig,__ ->
                    def mtd = srg['MD:'][cls + '/' + sig]
                    if (mtd && !mtd.contains('()') && mtd.contains('func_')) {
                        mtd = mtd.split(' ')[0]
                        methods.add(mtd.substring(mtd.lastIndexOf('/') + 1))
                    }
                }
            }

            dest.withWriter('UTF-8') { writer ->
                methods = methods.sort{it}
                methods.each{ writer.write(it + '\n') }
            }
        }
    }

    task makeExceptions(type: SingleOutput, dependsOn: [extractInheritance, makeSRG]) {
        inputs.file PATH_EXCEPTIONS
        dest file(PATH_CACHED_VERSION_DATA + 'exceptions.txt')
        doLast {
            def srg = loadSRG(makeSRG.dest)
            def json = new JsonSlurper().parseText(extractInheritance.dest.text)
            def known = [:]
            srg['MD:'].each{k,v -> known[v] = k}
            def methods = [:]

            def current_class = null
            def line_num = 0

            inputs.files.singleFile.eachLine { line ->
                line_num++
                if (line.indexOf('#') != -1)
                    line = line.substring(0, line.indexOf('#'))
                if (line.trim().isEmpty())
                    return

                def pts = line.trim().split(' ')
                if (line.startsWith('\t')) {
                    if (current_class == null)
                        throw new Exception('Invalid exceptions.txt format on line #' + line_num + ': ' + line)
                    def key = current_class + '/' + pts[0] + ' ' + pts[1]
                    if (!methods[key])
                        methods[key] = [] as HashSet
                    for (int x = 2; x < pts.length; x++)
                        methods[key].add(pts[x])
                } else if (pts.length == 1) {
                    current_class = pts[0]
                } else if (pts.length >= 3) {
                    current_class = null
                    def key = pts[0] + '/' + pts[1] + ' ' + pts[2]
                    if (!methods[key])
                        methods[key] = [] as HashSet
                    for (int x = 3; x < pts.length; x++)
                        methods[key].add(pts[x])
                } else
                    throw new Exception('Invalid exceptions.txt format on line #' + line_num + ': ' + line)
            }

            json.each{ k,v ->
                json[k]['methods']?.each{ sig,data ->
                    if (data['override']) {
                        def mtd = srg['MD:'][k + '/' + sig]
                        def ord = data['override'] + '/' + sig

                        if (srg['MD:'][ord])
                            ord = srg['MD:'][ord]

                        if (methods[ord]) {
                            if (!methods[mtd])
                                methods[mtd] = [] as HashSet
                            methods[ord].each{ methods[mtd].add(it) }

                            if (data['bouncer']) {
                                def bnc = srg['MD:'][k +'/' + data['bouncer']['name'] + ' ' + data['bouncer']['desc']]
                                if (!methods[bnc])
                                    methods[bnc] = [] as HashSet
                                methods[ord].each{ methods[bnc].add(it) }
                            }
                        }
                    }
                }
            }

            outputs.files.singleFile.withWriter('UTF-8') { writer ->
                methods.keySet().sort{it}.findAll{known.containsKey(it)}.each{ writer.write(it + ' ' + methods[it].join(' ') + '\n') }
            }
        }
    }

    task mcinjectClient(type: MCInjectorTask, dependsOn: [downloadMCInjector, renameClient, makeExceptions, fixAccessLevels]) {
        jar downloadMCInjector.dest
        inputs.file(downloadMCInjector.dest)
        inputs.file(renameClient.dest)
        inputs.file(makeExceptions.dest)
        standardOutput NULL_OUTPUT
        args MCINJECTOR.args
        access fixAccessLevels.dest
        constructors file(PATH_VERSION + 'constructors.txt')
        exceptions makeExceptions.dest
        input renameClient.dest
        output file(PATH_CACHED_VERSION + project.version + '.client.mci.jar')
        log file(PATH_CACHED_VERSION + project.version + '.client.mci.log')
    }
    task mcinjectServer(type: MCInjectorTask, dependsOn: [downloadMCInjector, renameServer, makeExceptions, fixAccessLevels]) {
        jar downloadMCInjector.dest
        inputs.file(downloadMCInjector.dest)
        inputs.file(renameServer.dest)
        inputs.file(makeExceptions.dest)
        standardOutput NULL_OUTPUT
        args MCINJECTOR.args
        access fixAccessLevels.dest
        constructors file(PATH_VERSION + 'constructors.txt')
        exceptions makeExceptions.dest
        input renameServer.dest
        output file(PATH_CACHED_VERSION + project.version + '.server.mci.jar')
        log file(PATH_CACHED_VERSION + project.version + '.server.mci.log')
    }
    task mcinjectJoined(type: MCInjectorTask, dependsOn: [downloadMCInjector, renameJoined, makeExceptions, fixAccessLevels]) {
        jar downloadMCInjector.dest
        inputs.file(downloadMCInjector.dest)
        inputs.file(renameJoined.dest)
        inputs.file(makeExceptions.dest)
        standardOutput NULL_OUTPUT
        args MCINJECTOR.args
        access fixAccessLevels.dest
        constructors file(PATH_VERSION + 'constructors.txt')
        exceptions makeExceptions.dest
        input renameJoined.dest
        output file(PATH_CACHED_VERSION + project.version + '.joined.mci.jar')
        log file(PATH_CACHED_VERSION + project.version + '.joined.mci.log')
    }
    task mcinjectJars(dependsOn: [mcinjectClient, mcinjectServer, mcinjectJoined]){}
        
    task fernflowerLibrariesClient(type: SingleOutput, dependsOn: [downloadLibraries]) {
        inputs.file downloadJson.dest
        dest file(PATH_CACHED_VERSION + project.version + '.client.fernflower.libs.txt')
        doLast {
            def json = new JsonSlurper().parseText(downloadJson.dest.text)
            dest.withWriter('UTF-8'){ writer ->
                json.libraries.collect{lib -> lib.downloads.artifact.path}.unique{a,b -> a <=> b}.each { lib -> writer.write('-e=' + file(PATH_CACHED_LIBRARIES + lib).absolutePath + '\n') }
            }
        }
    }
    task fernflowerLibrariesServer(type: SingleOutput, dependsOn: [filterServerExtra]) {
        inputs.file filterServerExtra.archivePath
        dest file(PATH_CACHED_VERSION + project.version + '.server.fernflower.libs.txt')
        doLast {
            dest.withWriter('UTF-8'){ writer -> writer.write('-e=' + filterServerExtra.archivePath.absolutePath + '\n') }
        }
    }
    task fernflowerClient(type: JavaExecOutput, dependsOn: [downloadFernflower, mcinjectClient, fernflowerLibrariesClient]) {
        inputs.file(downloadFernflower.dest)
        inputs.file(mcinjectClient.output)
        inputs.file(fernflowerLibrariesClient.dest)
        dest file(PATH_CACHED_VERSION + project.version + '.client.decomp.jar')
        main = '-jar'
        doFirst {
            standardOutput file(PATH_CACHED_VERSION + project.version + '.client.decomp.log').newOutputStream()
            args = [downloadFernflower.dest.absolutePath] + project.fillVariables([
                input: mcinjectClient.dest.absolutePath, 
                output: dest.absolutePath, 
                libraries: fernflowerLibrariesClient.dest.absolutePath
            ], FERNFLOWER.args)
        }
    }
    task fernflowerServer(type: JavaExecOutput, dependsOn: [downloadFernflower, mcinjectServer, fernflowerLibrariesServer]) {
        inputs.file(downloadFernflower.dest)
        inputs.file(mcinjectServer.output)
        inputs.file(fernflowerLibrariesServer.dest)
        dest file(PATH_CACHED_VERSION + project.version + '.server.decomp.jar')
        main = '-jar'
        doFirst {
            standardOutput file(PATH_CACHED_VERSION + project.version + '.server.decomp.log').newOutputStream()
            args = [downloadFernflower.dest.absolutePath] + project.fillVariables([
                input: mcinjectServer.dest.absolutePath, 
                output: dest.absolutePath, 
                libraries: fernflowerLibrariesServer.dest.absolutePath
            ], FERNFLOWER.args)
        }
    }
    task fernflowerJoined(type: JavaExecOutput, dependsOn: [downloadFernflower, mcinjectJoined, fernflowerLibrariesClient]) { //We use client libraries because its joined and needs everything. AFAIK there arnt any server specific libraries
        inputs.file(downloadFernflower.dest)
        inputs.file(mcinjectJoined.output)
        inputs.file(fernflowerLibrariesClient.dest)
        dest file(PATH_CACHED_VERSION + project.version + '.joined.decomp.jar')
        main = '-jar'
        doFirst {
            standardOutput file(PATH_CACHED_VERSION + project.version + '.joined.decomp.log').newOutputStream()
            args = [downloadFernflower.dest.absolutePath] + project.fillVariables([
                input: mcinjectJoined.dest.absolutePath, 
                output: dest.absolutePath, 
                libraries: fernflowerLibrariesClient.dest.absolutePath
            ], FERNFLOWER.args)
        }
    }
    task decompileJars(dependsOn: [fernflowerClient, fernflowerServer, fernflowerJoined]){} //Command line friendly batch method!
    
    def sides = [
        [name: 'Client', jsonlibs: true, extra: 'Client'],
        [name: 'Server', jsonlibs: false, extra: 'Server'],
        [name: 'Joined', jsonlibs: true, extra: 'Client']
    ]
    
    task projectAll
    task projectDelete
    task projectSetup
    task projectApplyPatches
    task projectMakePatches
    
    for (def child : sides) {
        def dir = file(child.name.toLowerCase())
        def dir_clean = new File(dir, 'clean')
        def dir_patched = new File(dir, 'patched')
        def dir_patches = file("patches/${child.name.toLowerCase()}")
        
        task "project${child.name}"(dependsOn: ["filter${child.extra}Extra"] + (child.jsonlibs ? [downloadJson] : [])) {
            inputs.file PROJECT_TEMPLATE
            if (child.jsonlibs)
                inputs.file downloadJson.dest
            if (PATH_INJECT != null)
                inputs.file PATH_INJECT
            outputs.file dir
            doLast {
                def name = child.name.toLowerCase()
                def root = outputs.files.singleFile.absolutePath
                if (!file(root).exists())
                    file(root).mkdirs()
                    
                //file(root + '/settings.gradle').withWriter('UTF-8'){ it.write("include 'clean', 'patched'") }
                
                def template = PROJECT_TEMPLATE.text
                def libraries = []
                
                if (child.jsonlibs)
                    libraries += new JsonSlurper().parse(downloadJson.dest).libraries.collect{lib -> "'${lib.name}'"}.unique{a,b -> a <=> b}                
                if (CONFIG?.libraries?.get(name) != null)
                    libraries += CONFIG.libraries.get(name).collect{"'${it}'"}
                libraries += ["files('${filterClientExtra.archivePath.absolutePath.replace('\\', '/')}')"]
                
                template = template.replace('{libraries}', 'compile ' + libraries.join('\n        compile '))
                template = template.replace('{distro}', name)
                template = template.replace('{inject}', PATH_INJECT == null ? null : "'${PATH_INJECT.absolutePath.replace('\\', '/')}'")
                
                file(root + '/build.gradle').withWriter('UTF-8'){ it.write(template) }
            }
        }
        tasks.getByName("project${child.name}").mustRunAfter "project${child.name}Delete"
        projectAll.dependsOn "project${child.name}"

        task "project${child.name}Delete"(type: Delete) {
            delete dir
        }
        projectDelete.dependsOn "project${child.name}Delete"

        task "project${child.name}Setup"(type: Copy, dependsOn: ["project${child.name}", "fernflower${child.name}"]) {
            from(zipTree(tasks.getByName("fernflower${child.name}").dest)){
                into 'clean'
            }
            from(zipTree(tasks.getByName("fernflower${child.name}").dest)){
                into 'patched'
            }
            destinationDir dir
            if (PATH_INJECT_TEMPLATE != null) {
                inputs.file PATH_INJECT_TEMPLATE
                doLast {
                    [dir_clean, dir_patched].each{ root ->
                        def template = PATH_INJECT_TEMPLATE.text
                        root.eachFileRecurse(FileType.DIRECTORIES) { src_dir ->
                            def pkg = src_dir.path.substring(root.path.length() + 1).replaceAll(Matcher.quoteReplacement(File.separator), '.')
                            new File(src_dir, 'package-info.java').withWriter('UTF-8'){ it.write(template.replace('{PACKAGE}', pkg)) }
                        }
                    }
                }
            }
        }
        tasks.getByName("project${child.name}Setup").mustRunAfter "project${child.name}"
        projectSetup.dependsOn "project${child.name}Setup"
        
        task "project${child.name}ApplyPatches"(type: ApplyPatchesTask, dependsOn: ["project${child.name}Delete", "project${child.name}Setup"]) {
            target dir_patched
            patches dir_patches
        }
        projectApplyPatches.dependsOn "project${child.name}ApplyPatches"

        task "project${child.name}MakePatches"(type: MakePatchesTask/*, dependsOn: ["project${child.name}Setup"]*/) {
            root dir_clean
            target dir_patched
            patches dir_patches
        }
        projectMakePatches.dependsOn "project${child.name}MakePatches"
    }
    
    task makeExceptorConfigOld(dependsOn: ['makeExceptions', 'fixAccessLevels']) {
        inputs.file PATH_VERSION + 'constructors.txt'
        inputs.file makeExceptions.outputs.files.singleFile
        inputs.file fixAccessLevels.outputs.files.singleFile
        outputs.file PATH_CACHED_VERSION_DATA + 'joined.exc'

        doLast {
            def params = [:]
            def exceptions = [:]
            def access = [:]
            file(PATH_VERSION + 'constructors.txt').eachLine{ line ->
                if (line.indexOf('#') != -1)
                    line = line.substring(0, line.indexOf('#'))
                if (line.trim().isEmpty())
                    return
                def pts = line.split(' ')
                def args = []
                def index = 1
                Type.getMethodType(pts[2]).argumentTypes.each{
                    args.add('p_i' + pts[0] + '_' + index + '_')
                    index += it.size
                }
                params[pts[1] + '.<init>' + pts[2]] = args
            }
            makeExceptions.outputs.files.singleFile.eachLine{line ->
                def pts = line.split(' ')
                def ind = pts[0].lastIndexOf('/')
                pts[0] = (pts[0].substring(0, ind) + '.' + pts[0].substring(ind+1)) + '' + pts[1]
                exceptions[pts[0]] = pts[2..(pts.length-1)]
            }
            fixAccessLevels.outputs.files.singleFile.eachLine{line ->
                def pts = line.split('=')
                if (pts.length == 2)
                    access[pts[0]] = pts[1]
            }

            def keys = [] as HashSet
            keys.addAll(params.keySet())
            keys.addAll(exceptions.keySet())
            keys.addAll(access.keySet())

            outputs.files.singleFile.withWriter('UTF-8') { writer ->
                keys.sort().each{ key ->
                    if (access[key])
                        writer.write(key + '=' + access[key] + '\n')
                    else {
                        def p = params[key] ? params[key] : []
                        def e = exceptions[key] ? exceptions[key] : []
                        if (p.size() > 0 || e.size() > 0)
                            writer.write(key + '=' + e.join(',') + '|' + p.join(',') + '\n')
                    }
                }
            }
        }
    }

    task makeExceptorConfig(dependsOn: ['makeExceptions', 'fixAccessLevels']) {
        outputs.file PATH_CACHED_VERSION_DATA + 'exceptor.cfg'
        doLast {        
            outputs.files.singleFile.withWriter('UTF-8') { writer ->
                writer.write('Version = 3.7\n')
                writer.write('Access = ' + fixAccessLevels.outputs.files.singleFile.name.replace(project.version +'_', '') + '\n')
                writer.write('Exceptions = ' + makeExceptions.outputs.files.singleFile.name.replace(project.version +'_', '') + '\n')
                writer.write('Constructors = constructors.txt\n')
                writer.write('LVT = LVT\n')
            }
        }
    }

    task makeZip(type: Zip, dependsOn: [makeSRG, makeExceptorConfigOld, dumpOverrides, dumpStatic, fixAccessLevels, makeExceptions]) {
        baseName = project.archivesBaseName
        classifier = 'srg'
        version = project.version
        destinationDir = file(PATH_DISTRO)

        from PATH_ASTYLE //Do we need this? Need to double check if astyle is run before patches.

        def patches = file(PATH_VERSION + 'patches')
        if (patches.exists()) {
            from(patches) {
                into 'patches'
            }
        }

        from makeSRG
        from makeExceptorConfig
        from makeExceptorConfigOld //TODO: Remove? Make a Injector config file specifying the version?
        from dumpOverrides
        from dumpStatic
        from fixAccessLevels
        from makeExceptions
        from file(PATH_VERSION + 'constructors.txt')
        //TODO: exceptor.json? I don't think we actually use this data.
        rename { it.replace project.version+'_', '' }
    }

    task makeCZip(type: Zip, dependsOn: ['makeZip', 'makeCSRG']) {
        baseName = project.archivesBaseName
        classifier = 'csrg'
        version = project.version
        destinationDir = file(PATH_DISTRO)
        
        from(zipTree(makeZip.outputs.files.singleFile)){
            exclude '**.srg'
        }
        from makeCSRG
        rename { it.replace project.version+'_', '' }
    }

    task verify(dependsOn: [mergeJars]) {
        inputs.file mergeJars.dest
        inputs.file('joined.tsrg')
        doLast {
            MappingVerifier mv = new MappingVerifier()
            mv.loadMap(file('joined.tsrg'))
            mv.loadJar(mergeJars.dest)
            mv.addDefaultTasks()
            if (!mv.verify()) {
                def die = false
                for (def t : mv.tasks) {
                    if (!t.errors.isEmpty()) {
                        logger.lifecycle('Task: ' + t.name)
                        t.errors.each{ logger.lifecycle('  ' + it.stripIndent()) }
                        if (t.name == 'OverrideNames') 
                            fixOverrides(t.errors, PATH_VERSION + 'joined.tsrg')
                        die |= t.name != 'OverrideNames'
                    }
                }
                if (die)
                    throw new RuntimeException("Verification failed");
            }
        }
    }
    //test.dependsOn(verify) ?

    task renameClasses() {
        doLast {
            def renames = [:]
            def rrenames = [:]
            file('renames.txt').eachLine{ line ->
                def (entry, comment) = splitComment(line)
                if (entry == null)
                    return
                def (o, n) = entry.split(' ')
                if (renames.containsKey(o))
                    throw RuntimeException('Duplicate: ' + line + ' Old: ' + o + ' ' + renames[o]);
                if (rrenames.containsKey(n.toLowerCase()))
                    throw RuntimeException('Already Claimed: ' + line + ' Old: ' + rrenames[n.toLowerCase()] + ' ' + n);
                renames[o] = n
                rrenames[n.toLowerCase()] = o
                logger.lifecycle('Rename: ' + o + ' -> ' + n)
            }
            
            def lines = file(PATH_VERSION + 'joined.tsrg').readLines()
            file(PATH_VERSION + 'joined.tsrg').withWriter('UTF-8') { writer ->
                lines.each { def line -> 
                    def (entry, comment) = splitComment(line)
                    if (line.startsWith('\t') || entry == null)
                        writer.write(line +'\n')
                    else {
                        def (obf, named) = entry.split(' ')
                        writer.write(obf + ' ' + rename(renames, named))
                        if (comment != null)
                            writer.write(' ' + comment)
                        writer.write('\n')
                    }
                }
            }
            
            lines = file(PATH_VERSION + 'constructors.txt').readLines()
            file(PATH_VERSION + 'constructors.txt').withWriter('UTF-8') { writer ->
                lines.each { def line -> 
                    def (entry, comment) = splitComment(line)
                    if (entry == null)
                        writer.write(line +'\n')
                    else {
                        def (id, cls, sig) = entry.split(' ')
                        writer.write(id + ' ' + rename(renames, cls) + ' ' + sig.replaceAll(/L([^;]+);/){m -> 'L' + rename(renames, m[1]) + ';'})
                        if (comment != null)
                            writer.write(' ' + comment)
                        writer.write('\n')
                    }
                }
            }
        }
    }

    task makeTZip(type: Zip, dependsOn: 'makeZip') {
        baseName = project.archivesBaseName
        classifier = 'tsrg'
        version = project.version
        destinationDir = file(PATH_DISTRO)
        
        from(zipTree(makeZip.outputs.files.singleFile)){
            exclude '**.srg'
        }
        from PATH_VERSION + 'joined.tsrg'
        rename { it.replace project.version+'_', '' }
    }

    artifacts {
        archives makeZip
        archives makeCZip
        archives makeTZip
    }

    uploadArchives {
        repositories.mavenDeployer {
            dependsOn 'build'
            if (rootProject.hasProperty('forgeMavenPassword')) {
                repository(url: "http://files.minecraftforge.net/maven/manage/upload") {
                    authentication(userName: rootProject.getProperty('forgeMavenUsername'), password: rootProject.getProperty('forgeMavenPassword'))
                }
            } else {
                repository(url: 'file://localhost/' + rootProject.file('repo').getAbsolutePath())
            }

            pom {
                groupId = project.group
                version = project.version
                artifactId = project.archivesBaseName
                project {
                    name project.archivesBaseName
                    packaging 'jar'
                    description 'MCPConfig'
                    url 'https://github.com/MinecraftForge/MCPConfig'
                }
            }
        }
    }
}

def fixOverrides(fixes, target) {
    def oldnames = [:]
    def newnames = [:]
    fixes.each{ line ->
        def (entry, comment) = splitComment(line.stripIndent())
        if (entry == null)
            return
        def pts = entry.split(' ')
        if (pts[0] == 'Override:') {
            if (pts.length != 7)
                throw new RuntimeException('Invalid override line: ' + line)
            def (cls, obf) = pts[1].split('/')
            oldnames.get(cls, [:])[obf + pts[2]] = pts[4]
            newnames.get(cls, [:])[obf + pts[2]] = pts[6]
        }
    }
    
    def lines = file(target).readLines()
    file(target).withWriter('UTF-8') { writer ->
        def currentCls = null
        for (def line : lines) {
            def (entry, comment) = splitComment(line)
            if (entry == null)
                writer.write(line +'\n')
            else if (!line.startsWith('\t')) {
                writer.write(line +'\n')
                currentCls = entry.split(' ')[0]
            } else {
                def pts = entry.substring(1).split(' ')
                if (pts.length != 3)
                    writer.write(line +'\n')
                else {
                    def key = pts[0] + pts[1]
                    if (oldnames.get(currentCls, [:]).containsKey(key)) {
                        writer.write('\t' + pts[0] + ' ' + pts[1] + ' ')
                        if (oldnames[currentCls][key] != pts[2]){
                            logger.lifecycle(String.format('  Skipped Rename: %s/%s %s Expected: %s Got: %s', currentCls, pts[0], pts[1], oldnames[currentCls][key], pts[2]))
                            writer.write(pts[2])
                        } else {
                            logger.lifecycle(String.format('  Rename: %s/%s %s %s -> %s', currentCls, pts[0], pts[1], pts[2], newnames[currentCls][key]))
                            writer.write(newnames[currentCls][key])
                        }
                        
                        if (comment != null)
                            writer.write(' ' + comment)
                        writer.write('\n')
                    } else {
                        writer.write(line +'\n')
                    }
                }
            }
        }
    }
}

class MergeJar extends DefaultTask {
    @InputFile File client
    @InputFile File server
    @InputFile File mappings
    @Input String version
    @Input boolean annotate = true
    @OutputFile File dest
    
    @TaskAction
    def doTask() {
        Merger merger = new Merger(client, server, dest)
        
        mappings.eachLine { line ->
            line = (line + '#').split('#')[0].stripIndent()
            if (line.startsWith('\t') || line.indexOf(' ') == -1)
                return
            merger.whitelist(line.split(' ')[0])
        }
        if (annotate)
            merger.annotate(AnnotationVersion.fromVersion(version))
        merger.keepData()
        merger.skipMeta()
        merger.process()
    }
}

class SingleOutput extends DefaultTask {
    @OutputFile File dest
}
class JavaExecOutput extends JavaExec {
    @OutputFile File dest
}

def loadSRG(file) {
    def ret = ['PK:': [:], 'CL:': [:], 'FD:': [:], 'MD:': [:]]
    def lines = file.readLines().collect{ line -> splitComment(line)[0] }.findAll{line -> line != null && !line.trim().isEmpty() }
    if (ret.containsKey(lines[0].split(' ')[0])) {
        lines.each { line ->
            def pts = line.split(' ')
            if (pts[0] == 'PK:' || pts[0] == 'CL:' || pts[0] == 'FD:')
                ret[pts[0]][pts[1]] = pts[2]
            else if (pts[0] == 'MD:')
                ret[pts[0]][pts[1] + ' ' + pts[2]] = pts[3] + ' ' + pts[4]
        }
    } else {
        def currentCls = null
        def classes = [:]
        lines.findAll{line -> !line.startsWith('\t') && line.split(' ').length == 2}.each{l -> classes[l.split(' ')[0]] = l.split(' ')[1]}
        lines.each { line ->
            if (line.startsWith('\t')) {
                if (currentCls == null)
                    throw new IllegalStateException('Invalid TSRG Line, Missing currentCls: ' + file.absolutePath)
                line = currentCls + ' ' + line.substring(1)
            }
            def pts = line.trim().split(' ')
            if (pts.length == 2) {
                currentCls = pts[0]
                ret['CL:'][pts[0]] = pts[1]
            } else if (pts.length == 3)
                ret['FD:'][pts[0] + '/' + pts[1]] = rename(classes, pts[0]) + '/' + pts[2]
            else if (pts.length == 4)
                ret['MD:'][pts[0] + '/' + pts[1] + ' ' + pts[2]] = rename(classes, pts[0]) + '/' + pts[3] + ' ' + pts[2].replaceAll(/L([^;]+);/){m -> 'L' + rename(classes, m[1]) + ';'}
        }
    }
    
    return ret
}

def rename(map, entry) {
    def start = entry.indexOf('$')
    return map.get(entry, (start == -1) ? entry : rename(map, entry.substring(0, start)) + entry.substring(start))
}

def splitComment(line) {
    def start = line.indexOf('#')
    if (start == -1)
        return [line, null]
    if (start == 0)
        return [null, line]
    return [line.substring(0, start - 1).replace('\\s+$', ''), line.substring(start)]
}

def getVersionIndex(prop, default_) {
    if (!project.hasProperty(prop))
        return default_
    if (!VERSIONS.contains(project.getProperty(prop))) 
        throw new IllegalArgumentException('Unknown version in ' + prop + ': ' + project.getProperty(prop) + ' Known: ' + VERSIONS.toString())
    return VERSIONS.indexOf(project.getProperty(prop))
}

def fillVariables(props, args) {
    def ret = []
    args.each{ arg -> 
        if (!arg.startsWith('{') || !arg.endsWith('}') || !props.containsKey(arg.substring(1, arg.length() -1))) {
            ret.add(arg)
        } else {
            def val = props.get(arg.substring(1, arg.length() - 1))
            ret.add(val instanceof File ? val.absolutePath : val.toString())
        }
    }
    return ret
}

def mavenPath(dep) {
    def pts = dep.split(':')
    return pts[0].replace('.', '/') + '/' + pts[1] + '/' + pts[2] + '/' + pts[1] + '-' + pts[2] + (pts.length > 3 ? '-' + pts[3] : '') + '.jar'
}

def template = project(':' + VERSIONS[0])
def start = getVersionIndex('startVersion', 0)
def end = getVersionIndex('endVersion', VERSIONS.size - 1)

if (start > end)
    throw new IllegalArgumentException('Invalid start and end range: ' + VERSIONS[start] + ' > ' + VERSIONS[end])

template.tasks.each{t ->
    def myTask = project.tasks.findByName(t.name) ?: project.tasks.create(t.name)
    for (int x = start; x <= end; x++) {
        myTask.dependsOn project(VERSIONS[x]).tasks.findByName(t.name)
    }
}

